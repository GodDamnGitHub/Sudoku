{"ast":null,"code":"(function (root) {\n  var sudoku = root.sudoku = {};\n  sudoku.DIGITS = \"123456789\";\n  var ROWS = \"ABCDEFGHI\";\n  var COLS = sudoku.DIGITS;\n  var SQUARES = null;\n  var UNITS = null;\n  var SQUARE_UNITS_MAP = null;\n  var SQUARE_PEERS_MAP = null;\n  var MIN_GIVENS = 17;\n  var NR_SQUARES = 81;\n  var DIFFICULTY = {\n    \"easy\": 62,\n    \"medium\": 53,\n    \"hard\": 44,\n    \"very-hard\": 35,\n    \"insane\": 26,\n    \"inhuman\": 17\n  };\n  sudoku.BLANK_CHAR = '.';\n  sudoku.BLANK_BOARD = \"....................................................\" + \".............................\";\n\n  function initialize() {\n    SQUARES = sudoku._cross(ROWS, COLS);\n    UNITS = sudoku._get_all_units(ROWS, COLS);\n    SQUARE_UNITS_MAP = sudoku._get_square_units_map(SQUARES, UNITS);\n    SQUARE_PEERS_MAP = sudoku._get_square_peers_map(SQUARES, SQUARE_UNITS_MAP);\n  }\n\n  sudoku.generate = function (difficulty, unique) {\n    if (typeof difficulty === \"string\" || typeof difficulty === \"undefined\") {\n      difficulty = DIFFICULTY[difficulty] || DIFFICULTY.easy;\n    }\n\n    difficulty = sudoku._force_range(difficulty, NR_SQUARES + 1, MIN_GIVENS);\n    unique = unique || true;\n    var blank_board = \"\";\n\n    for (var i = 0; i < NR_SQUARES; ++i) {\n      blank_board += '.';\n    }\n\n    var candidates = sudoku._get_candidates_map(blank_board);\n\n    var shuffled_squares = sudoku._shuffle(SQUARES);\n\n    for (var si in shuffled_squares) {\n      var square = shuffled_squares[si];\n\n      var rand_candidate_idx = sudoku._rand_range(candidates[square].length);\n\n      var rand_candidate = candidates[square][rand_candidate_idx];\n\n      if (!sudoku._assign(candidates, square, rand_candidate)) {\n        break;\n      }\n\n      var single_candidates = [];\n\n      for (var si in SQUARES) {\n        var square = SQUARES[si];\n\n        if (candidates[square].length == 1) {\n          single_candidates.push(candidates[square]);\n        }\n      }\n\n      if (single_candidates.length >= difficulty && sudoku._strip_dups(single_candidates).length >= 8) {\n        var board = \"\";\n        var givens_idxs = [];\n\n        for (var i in SQUARES) {\n          var square = SQUARES[i];\n\n          if (candidates[square].length == 1) {\n            board += candidates[square];\n            givens_idxs.push(i);\n          } else {\n            board += sudoku.BLANK_CHAR;\n          }\n        }\n\n        var nr_givens = givens_idxs.length;\n\n        if (nr_givens > difficulty) {\n          givens_idxs = sudoku._shuffle(givens_idxs);\n\n          for (var i = 0; i < nr_givens - difficulty; ++i) {\n            var target = parseInt(givens_idxs[i]);\n            board = board.substr(0, target) + sudoku.BLANK_CHAR + board.substr(target + 1);\n          }\n        }\n\n        if (sudoku.solve(board)) {\n          return board;\n        }\n      }\n    }\n\n    return sudoku.generate(difficulty);\n  };\n\n  sudoku.solve = function (board, reverse) {\n    var report = sudoku.validate_board(board);\n\n    if (report !== true) {\n      throw report;\n    }\n\n    var nr_givens = 0;\n\n    for (var i in board) {\n      if (board[i] !== sudoku.BLANK_CHAR && sudoku._in(board[i], sudoku.DIGITS)) {\n        ++nr_givens;\n      }\n    }\n\n    if (nr_givens < MIN_GIVENS) {\n      throw \"Too few givens. Minimum givens is \" + MIN_GIVENS;\n    }\n\n    reverse = reverse || false;\n\n    var candidates = sudoku._get_candidates_map(board);\n\n    var result = sudoku._search(candidates, reverse);\n\n    if (result) {\n      var solution = \"\";\n\n      for (var square in result) {\n        solution += result[square];\n      }\n\n      return solution;\n    }\n\n    return false;\n  };\n\n  sudoku.get_candidates = function (board) {\n    var report = sudoku.validate_board(board);\n\n    if (report !== true) {\n      throw report;\n    }\n\n    var candidates_map = sudoku._get_candidates_map(board);\n\n    if (!candidates_map) {\n      return false;\n    }\n\n    var rows = [];\n    var cur_row = [];\n    var i = 0;\n\n    for (var square in candidates_map) {\n      var candidates = candidates_map[square];\n      cur_row.push(candidates);\n\n      if (i % 9 == 8) {\n        rows.push(cur_row);\n        cur_row = [];\n      }\n\n      ++i;\n    }\n\n    return rows;\n  };\n\n  sudoku._get_candidates_map = function (board) {\n    var report = sudoku.validate_board(board);\n\n    if (report !== true) {\n      throw report;\n    }\n\n    var candidate_map = {};\n\n    var squares_values_map = sudoku._get_square_vals_map(board);\n\n    for (var si in SQUARES) {\n      candidate_map[SQUARES[si]] = sudoku.DIGITS;\n    }\n\n    for (var square in squares_values_map) {\n      var val = squares_values_map[square];\n\n      if (sudoku._in(val, sudoku.DIGITS)) {\n        var new_candidates = sudoku._assign(candidate_map, square, val);\n\n        if (!new_candidates) {\n          return false;\n        }\n      }\n    }\n\n    return candidate_map;\n  };\n\n  sudoku._search = function (candidates, reverse) {\n    if (!candidates) {\n      return false;\n    }\n\n    reverse = reverse || false;\n    var max_nr_candidates = 0;\n    var max_candidates_square = null;\n\n    for (var si in SQUARES) {\n      var square = SQUARES[si];\n      var nr_candidates = candidates[square].length;\n\n      if (nr_candidates > max_nr_candidates) {\n        max_nr_candidates = nr_candidates;\n        max_candidates_square = square;\n      }\n    }\n\n    if (max_nr_candidates === 1) {\n      return candidates;\n    }\n\n    var min_nr_candidates = 10;\n    var min_candidates_square = null;\n\n    for (si in SQUARES) {\n      var square = SQUARES[si];\n      var nr_candidates = candidates[square].length;\n\n      if (nr_candidates < min_nr_candidates && nr_candidates > 1) {\n        min_nr_candidates = nr_candidates;\n        min_candidates_square = square;\n      }\n    }\n\n    var min_candidates = candidates[min_candidates_square];\n\n    if (!reverse) {\n      for (var vi in min_candidates) {\n        var val = min_candidates[vi];\n        var candidates_copy = JSON.parse(JSON.stringify(candidates));\n\n        var candidates_next = sudoku._search(sudoku._assign(candidates_copy, min_candidates_square, val));\n\n        if (candidates_next) {\n          return candidates_next;\n        }\n      }\n    } else {\n      for (var vi = min_candidates.length - 1; vi >= 0; --vi) {\n        var val = min_candidates[vi];\n        var candidates_copy = JSON.parse(JSON.stringify(candidates));\n\n        var candidates_next = sudoku._search(sudoku._assign(candidates_copy, min_candidates_square, val), reverse);\n\n        if (candidates_next) {\n          return candidates_next;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  sudoku._assign = function (candidates, square, val) {\n    var other_vals = candidates[square].replace(val, \"\");\n\n    for (var ovi in other_vals) {\n      var other_val = other_vals[ovi];\n\n      var candidates_next = sudoku._eliminate(candidates, square, other_val);\n\n      if (!candidates_next) {\n        return false;\n      }\n    }\n\n    return candidates;\n  };\n\n  sudoku._eliminate = function (candidates, square, val) {\n    if (!sudoku._in(val, candidates[square])) {\n      return candidates;\n    }\n\n    candidates[square] = candidates[square].replace(val, '');\n    var nr_candidates = candidates[square].length;\n\n    if (nr_candidates === 1) {\n      var target_val = candidates[square];\n\n      for (var pi in SQUARE_PEERS_MAP[square]) {\n        var peer = SQUARE_PEERS_MAP[square][pi];\n\n        var candidates_new = sudoku._eliminate(candidates, peer, target_val);\n\n        if (!candidates_new) {\n          return false;\n        }\n      }\n    }\n\n    if (nr_candidates === 0) {\n      return false;\n    }\n\n    for (var ui in SQUARE_UNITS_MAP[square]) {\n      var unit = SQUARE_UNITS_MAP[square][ui];\n      var val_places = [];\n\n      for (var si in unit) {\n        var unit_square = unit[si];\n\n        if (sudoku._in(val, candidates[unit_square])) {\n          val_places.push(unit_square);\n        }\n      }\n\n      if (val_places.length === 0) {\n        return false;\n      } else if (val_places.length === 1) {\n        var candidates_new = sudoku._assign(candidates, val_places[0], val);\n\n        if (!candidates_new) {\n          return false;\n        }\n      }\n    }\n\n    return candidates;\n  };\n\n  sudoku._get_square_vals_map = function (board) {\n    var squares_vals_map = {};\n\n    if (board.length != SQUARES.length) {\n      throw \"Board/squares length mismatch.\";\n    } else {\n      for (var i in SQUARES) {\n        squares_vals_map[SQUARES[i]] = board[i];\n      }\n    }\n\n    return squares_vals_map;\n  };\n\n  sudoku._get_square_units_map = function (squares, units) {\n    var square_unit_map = {};\n\n    for (var si in squares) {\n      var cur_square = squares[si];\n      var cur_square_units = [];\n\n      for (var ui in units) {\n        var cur_unit = units[ui];\n\n        if (cur_unit.indexOf(cur_square) !== -1) {\n          cur_square_units.push(cur_unit);\n        }\n      }\n\n      square_unit_map[cur_square] = cur_square_units;\n    }\n\n    return square_unit_map;\n  };\n\n  sudoku._get_square_peers_map = function (squares, units_map) {\n    var square_peers_map = {};\n\n    for (var si in squares) {\n      var cur_square = squares[si];\n      var cur_square_units = units_map[cur_square];\n      var cur_square_peers = [];\n\n      for (var sui in cur_square_units) {\n        var cur_unit = cur_square_units[sui];\n\n        for (var ui in cur_unit) {\n          var cur_unit_square = cur_unit[ui];\n\n          if (cur_square_peers.indexOf(cur_unit_square) === -1 && cur_unit_square !== cur_square) {\n            cur_square_peers.push(cur_unit_square);\n          }\n        }\n      }\n\n      square_peers_map[cur_square] = cur_square_peers;\n    }\n\n    return square_peers_map;\n  };\n\n  sudoku._get_all_units = function (rows, cols) {\n    var units = [];\n\n    for (var ri in rows) {\n      units.push(sudoku._cross(rows[ri], cols));\n    }\n\n    for (var ci in cols) {\n      units.push(sudoku._cross(rows, cols[ci]));\n    }\n\n    var row_squares = [\"ABC\", \"DEF\", \"GHI\"];\n    var col_squares = [\"123\", \"456\", \"789\"];\n\n    for (var rsi in row_squares) {\n      for (var csi in col_squares) {\n        units.push(sudoku._cross(row_squares[rsi], col_squares[csi]));\n      }\n    }\n\n    return units;\n  };\n\n  sudoku.board_string_to_grid = function (board_string) {\n    var rows = [];\n    var cur_row = [];\n\n    for (var i in board_string) {\n      cur_row.push(board_string[i]);\n\n      if (i % 9 == 8) {\n        rows.push(cur_row);\n        cur_row = [];\n      }\n    }\n\n    return rows;\n  };\n\n  sudoku.board_grid_to_string = function (board_grid) {\n    var board_string = \"\";\n\n    for (var r = 0; r < 9; ++r) {\n      for (var c = 0; c < 9; ++c) {\n        board_string += board_grid[r][c];\n      }\n    }\n\n    return board_string;\n  };\n\n  sudoku.print_board = function (board) {\n    var report = sudoku.validate_board(board);\n\n    if (report !== true) {\n      throw report;\n    }\n\n    var V_PADDING = \" \";\n    var H_PADDING = '\\n';\n    var V_BOX_PADDING = \"  \";\n    var H_BOX_PADDING = '\\n';\n    var display_string = \"\";\n\n    for (var i in board) {\n      var square = board[i];\n      display_string += square + V_PADDING;\n\n      if (i % 3 === 2) {\n        display_string += V_BOX_PADDING;\n      }\n\n      if (i % 9 === 8) {\n        display_string += H_PADDING;\n      }\n\n      if (i % 27 === 26) {\n        display_string += H_BOX_PADDING;\n      }\n    }\n\n    console.log(display_string);\n  };\n\n  sudoku.validate_board = function (board) {\n    if (!board) {\n      return \"Empty board\";\n    }\n\n    if (board.length !== NR_SQUARES) {\n      return \"Invalid board size. Board must be exactly \" + NR_SQUARES + \" squares.\";\n    }\n\n    for (var i in board) {\n      if (!sudoku._in(board[i], sudoku.DIGITS) && board[i] !== sudoku.BLANK_CHAR) {\n        return \"Invalid board character encountered at index \" + i + \": \" + board[i];\n      }\n    }\n\n    return true;\n  };\n\n  sudoku._cross = function (a, b) {\n    var result = [];\n\n    for (var ai in a) {\n      for (var bi in b) {\n        result.push(a[ai] + b[bi]);\n      }\n    }\n\n    return result;\n  };\n\n  sudoku._in = function (v, seq) {\n    return seq.indexOf(v) !== -1;\n  };\n\n  sudoku._first_true = function (seq) {\n    for (var i in seq) {\n      if (seq[i]) {\n        return seq[i];\n      }\n    }\n\n    return false;\n  };\n\n  sudoku._shuffle = function (seq) {\n    var shuffled = [];\n\n    for (var i = 0; i < seq.length; ++i) {\n      shuffled.push(false);\n    }\n\n    for (var i in seq) {\n      var ti = sudoku._rand_range(seq.length);\n\n      while (shuffled[ti]) {\n        ti = ti + 1 > seq.length - 1 ? 0 : ti + 1;\n      }\n\n      shuffled[ti] = seq[i];\n    }\n\n    return shuffled;\n  };\n\n  sudoku._rand_range = function (max, min) {\n    min = min || 0;\n\n    if (max) {\n      return Math.floor(Math.random() * (max - min)) + min;\n    } else {\n      throw \"Range undefined\";\n    }\n  };\n\n  sudoku._strip_dups = function (seq) {\n    var seq_set = [];\n    var dup_map = {};\n\n    for (var i in seq) {\n      var e = seq[i];\n\n      if (!dup_map[e]) {\n        seq_set.push(e);\n        dup_map[e] = true;\n      }\n    }\n\n    return seq_set;\n  };\n\n  sudoku._force_range = function (nr, max, min) {\n    min = min || 0;\n    nr = nr || 0;\n\n    if (nr < min) {\n      return min;\n    }\n\n    if (nr > max) {\n      return max;\n    }\n\n    return nr;\n  };\n\n  initialize();\n})(this);","map":{"version":3,"sources":["/Users/felix/Library/Mobile Documents/com~apple~CloudDocs/Learning/Brandeis/CS153A/Projects/Sudoku/data/sudoku.js"],"names":["root","sudoku","DIGITS","ROWS","COLS","SQUARES","UNITS","SQUARE_UNITS_MAP","SQUARE_PEERS_MAP","MIN_GIVENS","NR_SQUARES","DIFFICULTY","BLANK_CHAR","BLANK_BOARD","initialize","_cross","_get_all_units","_get_square_units_map","_get_square_peers_map","generate","difficulty","unique","easy","_force_range","blank_board","i","candidates","_get_candidates_map","shuffled_squares","_shuffle","si","square","rand_candidate_idx","_rand_range","length","rand_candidate","_assign","single_candidates","push","_strip_dups","board","givens_idxs","nr_givens","target","parseInt","substr","solve","reverse","report","validate_board","_in","result","_search","solution","get_candidates","candidates_map","rows","cur_row","candidate_map","squares_values_map","_get_square_vals_map","val","new_candidates","max_nr_candidates","max_candidates_square","nr_candidates","min_nr_candidates","min_candidates_square","min_candidates","vi","candidates_copy","JSON","parse","stringify","candidates_next","other_vals","replace","ovi","other_val","_eliminate","target_val","pi","peer","candidates_new","ui","unit","val_places","unit_square","squares_vals_map","squares","units","square_unit_map","cur_square","cur_square_units","cur_unit","indexOf","units_map","square_peers_map","cur_square_peers","sui","cur_unit_square","cols","ri","ci","row_squares","col_squares","rsi","csi","board_string_to_grid","board_string","board_grid_to_string","board_grid","r","c","print_board","V_PADDING","H_PADDING","V_BOX_PADDING","H_BOX_PADDING","display_string","console","log","a","b","ai","bi","v","seq","_first_true","shuffled","ti","max","min","Math","floor","random","seq_set","dup_map","e","nr"],"mappings":"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","sourcesContent":["/*\n    Sudoku.js\n    ---------\n    A Sudoku puzzle generator and solver JavaScript library.\n    Please see the README for more details.\n*/\n\n(function(root){\n    var sudoku = root.sudoku = {};  // Global reference to the sudoku library\n\n    sudoku.DIGITS = \"123456789\";    // Allowed sudoku.DIGITS\n    var ROWS = \"ABCDEFGHI\";         // Row lables\n    var COLS = sudoku.DIGITS;       // Column lables\n    var SQUARES = null;             // Square IDs\n\n    var UNITS = null;               // All units (row, column, or box)\n    var SQUARE_UNITS_MAP = null;    // Squares -> units map\n    var SQUARE_PEERS_MAP = null;    // Squares -> peers map\n    \n    var MIN_GIVENS = 17;            // Minimum number of givens \n    var NR_SQUARES = 81;            // Number of squares\n    \n    // Define difficulties by how many squares are given to the player in a new\n    // puzzle.\n    var DIFFICULTY = {\n        \"easy\":         62,\n        \"medium\":       53,\n        \"hard\":         44,\n        \"very-hard\":    35,\n        \"insane\":       26,\n        \"inhuman\":      17,\n    };\n\n    // Blank character and board representation\n    sudoku.BLANK_CHAR = '.';\n    sudoku.BLANK_BOARD = \"....................................................\"+\n            \".............................\";\n\n    // Init\n    // -------------------------------------------------------------------------\n    function initialize(){\n        /* Initialize the Sudoku library (invoked after library load)\n        */\n        SQUARES             = sudoku._cross(ROWS, COLS);\n        UNITS               = sudoku._get_all_units(ROWS, COLS);\n        SQUARE_UNITS_MAP    = sudoku._get_square_units_map(SQUARES, UNITS);\n        SQUARE_PEERS_MAP    = sudoku._get_square_peers_map(SQUARES, \n                                    SQUARE_UNITS_MAP);\n    }\n\n    // Generate\n    // -------------------------------------------------------------------------\n    sudoku.generate = function(difficulty, unique){\n        /* Generate a new Sudoku puzzle of a particular `difficulty`, e.g.,\n        \n            // Generate an \"easy\" sudoku puzzle\n            sudoku.generate(\"easy\");\n            \n        \n        Difficulties are as follows, and represent the number of given squares:\n        \n                \"easy\":         61\n                \"medium\":       52\n                \"hard\":         43\n                \"very-hard\":    34\n                \"insane\":       25\n                \"inhuman\":      17\n            \n            \n        You may also enter a custom number of squares to be given, e.g.,\n        \n            // Generate a new Sudoku puzzle with 60 given squares\n            sudoku.generate(60)\n    \n    \n        `difficulty` must be a number between 17 and 81 inclusive. If it's\n        outside of that range, `difficulty` will be set to the closest bound,\n        e.g., 0 -> 17, and 100 -> 81.\n        \n        \n        By default, the puzzles are unique, uless you set `unique` to false. \n        (Note: Puzzle uniqueness is not yet implemented, so puzzles are *not* \n        guaranteed to have unique solutions)\n        \n        TODO: Implement puzzle uniqueness\n        */\n        \n        // If `difficulty` is a string or undefined, convert it to a number or\n        // default it to \"easy\" if undefined.\n        if(typeof difficulty === \"string\" || typeof difficulty === \"undefined\"){\n            difficulty = DIFFICULTY[difficulty] || DIFFICULTY.easy;\n        }\n        \n        // Force difficulty between 17 and 81 inclusive\n        difficulty = sudoku._force_range(difficulty, NR_SQUARES + 1, \n                MIN_GIVENS);\n        \n        // Default unique to true\n        unique = unique || true;\n        \n        // Get a set of squares and all possible candidates for each square\n        var blank_board = \"\";\n        for(var i = 0; i < NR_SQUARES; ++i){\n            blank_board += '.';\n        }\n        var candidates = sudoku._get_candidates_map(blank_board);\n        \n        // For each item in a shuffled list of squares\n        var shuffled_squares = sudoku._shuffle(SQUARES);\n        for(var si in shuffled_squares){\n            var square = shuffled_squares[si];\n            \n            // If an assignment of a random chioce causes a contradictoin, give\n            // up and try again\n            var rand_candidate_idx = \n                    sudoku._rand_range(candidates[square].length);\n            var rand_candidate = candidates[square][rand_candidate_idx];\n            if(!sudoku._assign(candidates, square, rand_candidate)){\n                break;\n            }\n            \n            // Make a list of all single candidates\n            var single_candidates = [];\n            for(var si in SQUARES){\n                var square = SQUARES[si];\n                \n                if(candidates[square].length == 1){\n                    single_candidates.push(candidates[square]);\n                }\n            }\n            \n            // If we have at least difficulty, and the unique candidate count is\n            // at least 8, return the puzzle!\n            if(single_candidates.length >= difficulty && \n                    sudoku._strip_dups(single_candidates).length >= 8){\n                var board = \"\";\n                var givens_idxs = [];\n                for(var i in SQUARES){\n                    var square = SQUARES[i];\n                    if(candidates[square].length == 1){\n                        board += candidates[square];\n                        givens_idxs.push(i);\n                    } else {\n                        board += sudoku.BLANK_CHAR;\n                    }\n                }\n                \n                // If we have more than `difficulty` givens, remove some random\n                // givens until we're down to exactly `difficulty`\n                var nr_givens = givens_idxs.length;\n                if(nr_givens > difficulty){\n                    givens_idxs = sudoku._shuffle(givens_idxs);\n                    for(var i = 0; i < nr_givens - difficulty; ++i){\n                        var target = parseInt(givens_idxs[i]);\n                        board = board.substr(0, target) + sudoku.BLANK_CHAR + \n                            board.substr(target + 1);\n                    }\n                }\n                \n                // Double check board is solvable\n                // TODO: Make a standalone board checker. Solve is expensive.\n                if(sudoku.solve(board)){\n                    return board;\n                }\n            }\n        }\n        \n        // Give up and try a new puzzle\n        return sudoku.generate(difficulty);\n    };\n\n    // Solve\n    // -------------------------------------------------------------------------\n    sudoku.solve = function(board, reverse){\n        /* Solve a sudoku puzzle given a sudoku `board`, i.e., an 81-character \n        string of sudoku.DIGITS, 1-9, and spaces identified by '.', representing the\n        squares. There must be a minimum of 17 givens. If the given board has no\n        solutions, return false.\n        \n        Optionally set `reverse` to solve \"backwards\", i.e., rotate through the\n        possibilities in reverse. Useful for checking if there is more than one\n        solution.\n        */\n        \n        // Assure a valid board\n        var report = sudoku.validate_board(board);\n        if(report !== true){\n            throw report;\n        }\n        \n        // Check number of givens is at least MIN_GIVENS\n        var nr_givens = 0;\n        for(var i in board){\n            if(board[i] !== sudoku.BLANK_CHAR && sudoku._in(board[i], sudoku.DIGITS)){\n                ++nr_givens;\n            }\n        }\n        if(nr_givens < MIN_GIVENS){\n            throw \"Too few givens. Minimum givens is \" + MIN_GIVENS;\n        }\n\n        // Default reverse to false\n        reverse = reverse || false;\n\n        var candidates = sudoku._get_candidates_map(board);\n        var result = sudoku._search(candidates, reverse);\n        \n        if(result){\n            var solution = \"\";\n            for(var square in result){\n                solution += result[square];\n            }\n            return solution;\n        }\n        return false;\n    };\n\n    sudoku.get_candidates = function(board){\n        /* Return all possible candidatees for each square as a grid of \n        candidates, returnning `false` if a contradiction is encountered.\n        \n        Really just a wrapper for sudoku._get_candidates_map for programmer\n        consumption.\n        */\n        \n        // Assure a valid board\n        var report = sudoku.validate_board(board);\n        if(report !== true){\n            throw report;\n        }\n        \n        // Get a candidates map\n        var candidates_map = sudoku._get_candidates_map(board);\n        \n        // If there's an error, return false\n        if(!candidates_map){\n            return false;\n        }\n        \n        // Transform candidates map into grid\n        var rows = [];\n        var cur_row = [];\n        var i = 0;\n        for(var square in candidates_map){\n            var candidates = candidates_map[square];\n            cur_row.push(candidates);\n            if(i % 9 == 8){\n                rows.push(cur_row);\n                cur_row = [];\n            }\n            ++i;\n        }\n        return rows;\n    }\n\n    sudoku._get_candidates_map = function(board){\n        /* Get all possible candidates for each square as a map in the form\n        {square: sudoku.DIGITS} using recursive constraint propagation. Return `false` \n        if a contradiction is encountered\n        */\n        \n        // Assure a valid board\n        var report = sudoku.validate_board(board);\n        if(report !== true){\n            throw report;\n        }\n        \n        var candidate_map = {};\n        var squares_values_map = sudoku._get_square_vals_map(board);\n        \n        // Start by assigning every digit as a candidate to every square\n        for(var si in SQUARES){\n            candidate_map[SQUARES[si]] = sudoku.DIGITS;\n        }\n        \n        // For each non-blank square, assign its value in the candidate map and\n        // propigate.\n        for(var square in squares_values_map){\n            var val = squares_values_map[square];\n            \n            if(sudoku._in(val, sudoku.DIGITS)){\n                var new_candidates = sudoku._assign(candidate_map, square, val);\n                \n                // Fail if we can't assign val to square\n                if(!new_candidates){\n                    return false;\n                }\n            }\n        }\n        \n        return candidate_map;\n    };\n\n    sudoku._search = function(candidates, reverse){\n        /* Given a map of squares -> candiates, using depth-first search, \n        recursively try all possible values until a solution is found, or false\n        if no solution exists. \n        */\n        \n        // Return if error in previous iteration\n        if(!candidates){\n            return false;\n        }\n        \n        // Default reverse to false\n        reverse = reverse || false;\n        \n        // If only one candidate for every square, we've a solved puzzle!\n        // Return the candidates map.\n        var max_nr_candidates = 0;\n        var max_candidates_square = null;\n        for(var si in SQUARES){\n            var square = SQUARES[si];\n            \n            var nr_candidates = candidates[square].length;\n                \n            if(nr_candidates > max_nr_candidates){\n                max_nr_candidates = nr_candidates;\n                max_candidates_square = square;\n            }\n        }\n        if(max_nr_candidates === 1){\n            return candidates;\n        }\n        \n        // Choose the blank square with the fewest possibilities > 1\n        var min_nr_candidates = 10;\n        var min_candidates_square = null;\n        for(si in SQUARES){\n            var square = SQUARES[si];\n            \n            var nr_candidates = candidates[square].length;\n            \n            if(nr_candidates < min_nr_candidates && nr_candidates > 1){\n                min_nr_candidates = nr_candidates;\n                min_candidates_square = square;\n            }\n        }\n        \n        // Recursively search through each of the candidates of the square \n        // starting with the one with fewest candidates.\n        \n        // Rotate through the candidates forwards\n        var min_candidates = candidates[min_candidates_square];\n        if(!reverse){\n            for(var vi in min_candidates){\n                var val = min_candidates[vi];\n                \n                // TODO: Implement a non-rediculous deep copy function\n                var candidates_copy = JSON.parse(JSON.stringify(candidates));\n                var candidates_next = sudoku._search(\n                    sudoku._assign(candidates_copy, min_candidates_square, val)\n                );\n                \n                if(candidates_next){\n                    return candidates_next;\n                }\n            }\n            \n        // Rotate through the candidates backwards\n        } else {\n            for(var vi = min_candidates.length - 1; vi >= 0; --vi){\n                var val = min_candidates[vi];\n                \n                // TODO: Implement a non-rediculous deep copy function\n                var candidates_copy = JSON.parse(JSON.stringify(candidates));\n                var candidates_next = sudoku._search(\n                    sudoku._assign(candidates_copy, min_candidates_square, val), \n                    reverse\n                );\n                \n                if(candidates_next){\n                    return candidates_next;\n                }\n            }\n        }\n        \n        // If we get through all combinations of the square with the fewest\n        // candidates without finding an answer, there isn't one. Return false.\n        return false;\n    };\n\n    sudoku._assign = function(candidates, square, val){\n        /* Eliminate all values, *except* for `val`, from `candidates` at \n        `square` (candidates[square]), and propagate. Return the candidates map\n        when finished. If a contradiciton is found, return false.\n        \n        WARNING: This will modify the contents of `candidates` directly.\n        */\n\n        // Grab a list of canidates without 'val'\n        var other_vals = candidates[square].replace(val, \"\");\n\n        // Loop through all other values and eliminate them from the candidates \n        // at the current square, and propigate. If at any point we get a \n        // contradiction, return false.\n        for(var ovi in other_vals){\n            var other_val = other_vals[ovi];\n\n            var candidates_next =\n                sudoku._eliminate(candidates, square, other_val);\n\n            if(!candidates_next){\n                //console.log(\"Contradiction found by _eliminate.\");\n                return false;\n            }\n        }\n\n        return candidates;\n    };\n\n    sudoku._eliminate = function(candidates, square, val){\n        /* Eliminate `val` from `candidates` at `square`, (candidates[square]),\n        and propagate when values or places <= 2. Return updated candidates,\n        unless a contradiction is detected, in which case, return false.\n        \n        WARNING: This will modify the contents of `candidates` directly.\n        */\n\n        // If `val` has already been eliminated from candidates[square], return\n        // with candidates.\n        if(!sudoku._in(val, candidates[square])){\n            return candidates;\n        }\n\n        // Remove `val` from candidates[square]\n        candidates[square] = candidates[square].replace(val, '');\n           \n        // If the square has only candidate left, eliminate that value from its \n        // peers\n        var nr_candidates = candidates[square].length;\n        if(nr_candidates === 1){\n            var target_val = candidates[square];\n            \n            for(var pi in SQUARE_PEERS_MAP[square]){\n                var peer = SQUARE_PEERS_MAP[square][pi];\n                \n                var candidates_new = \n                        sudoku._eliminate(candidates, peer, target_val);\n                        \n                if(!candidates_new){\n                    return false;\n                }\n            }\n        \n        // Otherwise, if the square has no candidates, we have a contradiction.\n        // Return false.\n        } if(nr_candidates === 0){\n            return false;\n        }\n        \n        // If a unit is reduced to only one place for a value, then assign it\n        for(var ui in SQUARE_UNITS_MAP[square]){\n            var unit = SQUARE_UNITS_MAP[square][ui];\n            \n            var val_places = [];\n            for(var si in unit){\n                var unit_square = unit[si];\n                if(sudoku._in(val, candidates[unit_square])){\n                    val_places.push(unit_square);\n                }\n            }\n            \n            // If there's no place for this value, we have a contradition!\n            // return false\n            if(val_places.length === 0){\n                return false;\n                \n            // Otherwise the value can only be in one place. Assign it there.\n            } else if(val_places.length === 1){\n                var candidates_new = \n                    sudoku._assign(candidates, val_places[0], val);\n                \n                if(!candidates_new){\n                    return false;\n                }\n            }\n        }\n        \n        return candidates;\n    };\n\n    \n    // Square relationships\n    // -------------------------------------------------------------------------\n    // Squares, and their relationships with values, units, and peers.\n    \n    sudoku._get_square_vals_map = function(board){\n        /* Return a map of squares -> values\n        */\n        var squares_vals_map = {};\n        \n        // Make sure `board` is a string of length 81\n        if(board.length != SQUARES.length){\n            throw \"Board/squares length mismatch.\";\n            \n        } else {\n            for(var i in SQUARES){\n                squares_vals_map[SQUARES[i]] = board[i];\n            }\n        }\n        \n        return squares_vals_map;\n    };\n\n    sudoku._get_square_units_map = function(squares, units){\n        /* Return a map of `squares` and their associated units (row, col, box)\n        */\n        var square_unit_map = {};\n\n        // For every square...\n        for(var si in squares){\n            var cur_square = squares[si];\n\n            // Maintain a list of the current square's units\n            var cur_square_units = [];\n\n            // Look through the units, and see if the current square is in it,\n            // and if so, add it to the list of of the square's units.\n            for(var ui in units){\n                var cur_unit = units[ui];\n\n                if(cur_unit.indexOf(cur_square) !== -1){\n                    cur_square_units.push(cur_unit);\n                }\n            }\n\n            // Save the current square and its units to the map\n            square_unit_map[cur_square] = cur_square_units;\n        }\n\n        return square_unit_map;\n    };\n\n    sudoku._get_square_peers_map = function(squares, units_map){\n        /* Return a map of `squares` and their associated peers, i.e., a set of\n        other squares in the square's unit.\n        */\n        var square_peers_map = {};\n\n        // For every square...\n        for(var si in squares){\n            var cur_square = squares[si];\n            var cur_square_units = units_map[cur_square];\n\n            // Maintain list of the current square's peers\n            var cur_square_peers = [];\n\n            // Look through the current square's units map...\n            for(var sui in cur_square_units){\n                var cur_unit = cur_square_units[sui];\n\n                for(var ui in cur_unit){\n                    var cur_unit_square = cur_unit[ui];\n\n                    if(cur_square_peers.indexOf(cur_unit_square) === -1 && \n                            cur_unit_square !== cur_square){\n                        cur_square_peers.push(cur_unit_square);\n                    }\n                }\n            }\n            \n            // Save the current square an its associated peers to the map\n            square_peers_map[cur_square] = cur_square_peers;\n        }\n\n        return square_peers_map;\n    };\n    \n    sudoku._get_all_units = function(rows, cols){\n        /* Return a list of all units (rows, cols, boxes)\n        */\n        var units = [];\n\n        // Rows\n        for(var ri in rows){\n            units.push(sudoku._cross(rows[ri], cols));\n        }\n\n        // Columns\n        for(var ci in cols){\n           units.push(sudoku._cross(rows, cols[ci]));\n        }\n\n        // Boxes\n        var row_squares = [\"ABC\", \"DEF\", \"GHI\"];\n        var col_squares = [\"123\", \"456\", \"789\"];\n        for(var rsi in row_squares){\n            for(var csi in col_squares){\n                units.push(sudoku._cross(row_squares[rsi], col_squares[csi]));\n            }\n        }\n\n        return units;\n    };\n    \n\n    // Conversions\n    // -------------------------------------------------------------------------\n    sudoku.board_string_to_grid = function(board_string){\n        /* Convert a board string to a two-dimensional array\n        */\n        var rows = [];\n        var cur_row = [];\n        for(var i in board_string){\n            cur_row.push(board_string[i]);\n            if(i % 9 == 8){\n                rows.push(cur_row);\n                cur_row = [];\n            }\n        }\n        return rows;\n    };\n    \n    sudoku.board_grid_to_string = function(board_grid){\n        /* Convert a board grid to a string\n        */\n        var board_string = \"\";\n        for(var r = 0; r < 9; ++r){\n            for(var c = 0; c < 9; ++c){\n                board_string += board_grid[r][c];\n            }   \n        }\n        return board_string;\n    };\n    \n\n    // Utility\n    // -------------------------------------------------------------------------\n\n    sudoku.print_board = function(board){\n        /* Print a sudoku `board` to the console.\n        */\n        \n        // Assure a valid board\n        var report = sudoku.validate_board(board);\n        if(report !== true){\n            throw report;\n        }\n        \n        var V_PADDING = \" \";  // Insert after each square\n        var H_PADDING = '\\n'; // Insert after each row\n        \n        var V_BOX_PADDING = \"  \"; // Box vertical padding\n        var H_BOX_PADDING = '\\n'; // Box horizontal padding\n\n        var display_string = \"\";\n        \n        for(var i in board){\n            var square = board[i];\n            \n            // Add the square and some padding\n            display_string += square + V_PADDING;\n            \n            // Vertical edge of a box, insert v. box padding\n            if(i % 3 === 2){\n                display_string += V_BOX_PADDING;\n            }\n            \n            // End of a line, insert horiz. padding\n            if(i % 9 === 8){\n                display_string += H_PADDING;\n            }\n            \n            // Horizontal edge of a box, insert h. box padding\n            if(i % 27 === 26){\n                display_string += H_BOX_PADDING;\n            }\n        }\n\n        console.log(display_string);\n    };\n\n    sudoku.validate_board = function(board){\n        /* Return if the given `board` is valid or not. If it's valid, return\n        true. If it's not, return a string of the reason why it's not.\n        */\n        \n        // Check for empty board\n        if(!board){\n            return \"Empty board\";\n        }\n        \n        // Invalid board length\n        if(board.length !== NR_SQUARES){\n            return \"Invalid board size. Board must be exactly \" + NR_SQUARES +\n                    \" squares.\";\n        }\n        \n        // Check for invalid characters\n        for(var i in board){\n            if(!sudoku._in(board[i], sudoku.DIGITS) && board[i] !== sudoku.BLANK_CHAR){\n                return \"Invalid board character encountered at index \" + i + \n                        \": \" + board[i];\n            }\n        }\n        \n        // Otherwise, we're good. Return true.\n        return true;\n    };\n\n    sudoku._cross = function(a, b){\n        /* Cross product of all elements in `a` and `b`, e.g.,\n        sudoku._cross(\"abc\", \"123\") ->\n        [\"a1\", \"a2\", \"a3\", \"b1\", \"b2\", \"b3\", \"c1\", \"c2\", \"c3\"]\n        */\n        var result = [];\n        for(var ai in a){\n            for(var bi in b){\n                result.push(a[ai] + b[bi]);\n            }\n        }\n        return result;\n    };\n    \n    sudoku._in = function(v, seq){\n        /* Return if a value `v` is in sequence `seq`.\n        */\n        return seq.indexOf(v) !== -1;\n    };\n    \n    sudoku._first_true = function(seq){\n        /* Return the first element in `seq` that is true. If no element is\n        true, return false.\n        */\n        for(var i in seq){\n            if(seq[i]){\n                return seq[i];\n            }\n        }\n        return false;\n    };\n\n    sudoku._shuffle = function(seq){\n        /* Return a shuffled version of `seq`\n        */\n        \n        // Create an array of the same size as `seq` filled with false\n        var shuffled = [];\n        for(var i = 0; i < seq.length; ++i){\n            shuffled.push(false);\n        }\n        \n        for(var i in seq){\n            var ti = sudoku._rand_range(seq.length);\n            \n            while(shuffled[ti]){\n                ti = (ti + 1) > (seq.length - 1) ? 0 : (ti + 1);\n            }\n            \n            shuffled[ti] = seq[i];\n        }\n        \n        return shuffled;\n    };\n\n    sudoku._rand_range = function(max, min){\n        /* Get a random integer in the range of `min` to `max` (non inclusive).\n        If `min` not defined, default to 0. If `max` not defined, throw an \n        error.\n        */\n        min = min || 0;\n        if(max){\n            return Math.floor(Math.random() * (max - min)) + min;\n        } else {\n            throw \"Range undefined\";\n        }\n    };\n\n    sudoku._strip_dups = function(seq){\n        /* Strip duplicate values from `seq`\n        */\n        var seq_set = [];\n        var dup_map = {};\n        for(var i in seq){\n            var e = seq[i];\n            if(!dup_map[e]){\n                seq_set.push(e);\n                dup_map[e] = true;\n            }\n        }\n        return seq_set;\n    };\n    \n    sudoku._force_range = function(nr, max, min){\n        /* Force `nr` to be within the range from `min` to, but not including, \n        `max`. `min` is optional, and will default to 0. If `nr` is undefined,\n        treat it as zero.\n        */\n        min = min || 0\n        nr = nr || 0\n        if(nr < min){\n            return min;\n        }\n        if(nr > max){\n            return max;\n        }\n        return nr\n    }\n\n    // Initialize library after load\n    initialize();\n\n// Pass whatever the root object is, lsike 'window' in browsers\n})(this);"]},"metadata":{},"sourceType":"script"}